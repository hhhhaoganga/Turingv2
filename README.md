# Turingv2 逻辑电路模拟器

**一个基于 C++/Qt 实现的、受游戏《图灵完备》启发的、支持时序逻辑与自定义封装的可视化逻辑电路模拟器。**

> **下载与使用:**
>
> - **[点击此处直接下载最新 Release 版本 (Windows x64)](https://github.com/hhhhaoganga/Turingv2/releases/latest)**，无需编译，解压即用。
> - 详细的用户入门指南请参阅 **`USER_README.md`**。

---

## 核心特性

- **可视化编辑:** 支持拖拽放置、连线、删除等直观的电路图编辑操作。
- **实时仿真:** 所有逻辑门状态实时计算并以颜色反馈，信号流动清晰可见。
- **时序逻辑支持:** 独创的仿真机制，能够正确模拟和搭建**锁存器、触发器、寄存器**等复杂的时序电路。
- **无限层级封装:** 可将任意电路封装为自定义元件，并自动添加到工具栏，支持封装元件的嵌套使用。
- **多文档界面:** 支持多标签页，可同时编辑和运行多个独立的电路项目。
- **持久化存储:** 支持将电路设计保存为 `.json` 文件，并能随时打开恢复。

## 架构设计：一个三层分离的模型

本项目采用经典的前后端分离架构，确保了代码的**高内聚、低耦合**，为项目的可维护性和扩展性打下了坚实基础。

1.  **引擎层 (`engine`):**
    - **纯C++后端，与图形无关。** 负责电路的逻辑建模、仿真计算和文件序列化。
    - 核心是 `Component`, `Pin`, `Wire` 等数据类，以及负责管理和驱动一切的 `Engine` 类。

2.  **视图层 (`view`):**
    - **后端数据的“视觉代理人”。** 负责将引擎中的逻辑元件和状态，以图形的方式绘制在屏幕上。
    - 核心是继承自 `QGraphicsItem` 的 `ComponentItem` 和 `WireItem`，它们的 `paint()` 函数决定了电路的外观。

3.  **交互层 (`interaction`):**
    - **连接用户与引擎的“桥梁”。** 核心是自定义的 `GraphicsScene`，它负责捕获用户的鼠标操作（点击、拖拽、右键），并将其“翻译”成对引擎的调用指令（如`engine->createComponent()`）。

---

## 亮点与设计抉择 (Design Highlights & Trade-offs)

### 1. 仿真核心: `simulate()` 的“迭代求稳”与“微型锁存器”

本项目的仿真内核并未采用工业界复杂的事件驱动模型，而是实现了一种简洁而强大的**迭代求稳**循环。

- **核心机制:** 每一轮仿真迭代，我们都会 **“清零所有非源头输入引脚，但保留所有输出引脚的状态”**。
- **一箭双雕的效果:**
    1.  **解决“幽灵信号”:** “清零输入”确保了删除导线等结构变化能被正确响应，避免了输入引脚残留旧状态的BUG。
    2.  **实现时序逻辑:** “保留输出”这一关键操作，巧妙地让每一个输出引脚都成为了一个能将状态保持一个计算周期的**“微型锁存器”**。这为电路引入了“单位逻辑延迟”的概念，是所有时序逻辑（如锁存器、寄存器）能够正确运行的基石。
- **健壮性:** 循环上限设为100次，以优雅地处理振荡电路（如时钟），防止程序卡死。

> **关于上电复位:** 正如真实硬件，加载文件后（模拟上电），对称的时序电路可能进入亚稳态。此时只需像操作物理电路一样，通过输入信号进行一次**手动复位**，即可使其进入确定的工作状态。

### 2. 封装机制：数据驱动与自包含设计

封装功能的设计摒弃了复杂的父子窗口依赖，采用了更现代的数据驱动方案。

- **元件即文件:** 任何画布上的电路都可以被序列化为一个 `.json` 文件，存放在 `/components` 目录下。程序启动时会自动扫描此目录，动态生成工具栏按钮。
- **自包含存档:** 保存一个包含封装元件的电路时，该封装元件的完整JSON定义会**被嵌套地**写入主存档文件中。这使得存档文件是完全自包含的，分享和加载时无需依赖外部元件库。
- **无限嵌套:** 该机制天然支持无限层级的封装（封装元件内部可以使用其他封装元件）。

### 3. 架构权衡：面向对象 vs. 极致性能

在设计引脚状态的存储方式时，我们面临一个经典的架构权衡：

- **当前选择 (面向对象):** 将0/1状态存储在独立的 **`Pin` 类对象**中。
    - **优点:** 极佳的**封装性**和**代码可读性**。`Pin` 类很好地承担了所有与引脚相关的职责（如计算屏幕位置），使得高层代码（如连线交互）编写起来非常直观和优雅。
    - **代价:** 性能较低。由于`Pin`对象在内存中是分散的，访问时会产生多次“指针跳跃”，导致**CPU缓存效率**不高。

- **备选方案 (数据驱动):** 将状态存储在`Component`的**`bool`数组**中，并结合**查表法(LUT)**。
    - **优点:** 极致的**性能**。数据连续存储，**缓存极其友好**，能将单次`evaluate`的理论成本降低数倍。
    - **代价:** 牺牲了封装性，高层代码会变得笨拙（如需传递`(Component*, index)`来引用引脚）。

> **我们的决策:** 对于一个以可视化、交互和架构清晰度为首要目标的教育性项目，当前面向对象的方案是**更优的选择**。它体现了我们在“**优雅的工程实践**”和“**极限的性能压榨**”之间做出的主动设计决策。

---

## 未来改进方向

- **性能优化:** 实现“活动驱动”的`simulate`函数，只对输入状态变化的元件调用`evaluate`，将性能从与“电路总规模”相关提升到与“信号活动规模”相关。
- **交互体验:**
    - 增加**总线 (Bus)**、**分线器 (Splitter)** 和可设置数值的**总电源**，以支持多位运算。
    - 实现对元件和电路图的**注释**功能，方便理解复杂设计。
    - 增加**短路警告**和更明确的振荡提示。
- **工程健壮性:**
    - 引入**撤销/重做 (Undo/Redo)**框架。
    - 优化封装元件的存档机制，避免重复存储相同的封装定义。
- **UI便利性:**
    - 优化封装元件工具栏，支持排序和分组。
    - 增加双击工具栏按钮实现快捷放置等功能。

## 构建与协作

本项目使用 `CMake` 构建，推荐使用 `Qt Creator` 打开。协作流程基于 `Git` 的**功能分支工作流**，通过 `Pull Request` 和代码审查来保证代码质量。详细的提交历史展示了项目的完整迭代过程。